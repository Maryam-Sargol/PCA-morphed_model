# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_STD.ipynb.

# %% auto 0
__all__ = ['desired_STD']

# %% ../nbs/03_STD.ipynb 2
import numpy as np

# %% ../nbs/03_STD.ipynb 3
def desired_STD(coefficients: np.array, # PCA-coefficients
                 pca_mean: np.array, # PCA-mean
                 scores: np.array,  # PCA-scores
                 pca_index: int, # The component you want to evaluate (starts from 0)
                 k:int ) : # desired scaling factor 
    """ This function explains how much the data will change along specific pc by standard deviation."""
    
    score_std = np.std (scores[:,pca_index], axis=0, ddof=1)
    modified_data_with_pos_std =  pca_mean + k * score_std   *  coefficients[:,pca_index]  
    modified_data_with_neg_std =  pca_mean - k * score_std  *  coefficients[:,pca_index]
    modified_data_without_std =  pca_mean
    """pca_mean represents the mean vector of the original data, k is a scaling factor, and score_std is the standard deviation of
      the transformed data for the chosen principal component. Coefficients represents the coefficient corresponding to 
      the selected principal component. Size of each variable is:
      coefficients : (No of components, No of features),
      pca_mean: (No of features),
      scores:(No of samples, No of components),
      score_std:scalar,
      """


    # Reshape the list into groups of 3 (x, y, z)
    coordinates_pos = [modified_data_with_pos_std[i:i+3] for i in range(0, len(modified_data_with_pos_std), 3)]
    coordinates_neg = [modified_data_with_neg_std[i:i+3] for i in range(0, len(modified_data_with_neg_std), 3)]
    coordinates_mean = [modified_data_without_std[i:i+3] for i in range(0, len(modified_data_without_std), 3)]
   

    return coordinates_pos, coordinates_neg, coordinates_mean
